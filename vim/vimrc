" Pathogen: https://github.com/tpope/vim-pathogen
runtime bundle/vim-pathogen/autoload/pathogen.vim
call pathogen#infect()

filetype plugin on
" syntax highlighting
syntax enable
" dark background for 256-color mode (see http://www.iterm2.com/#/section/faq)
set background=dark
" xoria256 colorscheme - see http://www.vim.org/scripts/script.php?script_id=2140
"colorscheme solarized
colorscheme Monokai-Refined
" line numbers shown
set number
" relative line numbers - cool!
if exists('+relativenumber')
  set relativenumber
endif
" keep current cursor position when scrolling up and down
set nostartofline
" set up code block folding
highlight FoldColumn ctermbg=black ctermfg=darkred
highlight Folded ctermbg=black ctermfg=darkred
" now set foldlevels on start correctly
" http://vim.wikia.com/wiki/Folding
augroup vimrc
  au BufReadPre * setlocal foldmethod=indent
  au BufWinEnter * if &fdm == 'indent' | setlocal foldmethod=manual | endif
augroup END
" enable system clipboard (as per http://vim.wikia.com/wiki/VimTip687#Comments)
set clipboard=unnamed

" Clostag
" See http://mirnazim.org/writings/vim-plugins-i-use/
autocmd FileType html,htmldjango,jinjahtml,eruby,mako let b:closetag_html_style=1
autocmd FileType html,xhtml,xml,htmldjango,jinjahtml,eruby,mako source ~/.vim/bundle/closetag/plugin/closetag.vim

" Playing with settings from http://stevelosh.com/blog/2010/09/coming-home-to-vim/
" turn off vi compatible
set nocompatible
set encoding=utf-8
set scrolloff=3
set autoindent
set showmode
set showcmd
set hidden
set wildmenu
set wildmode=list:longest
set visualbell
set cursorline
set ttyfast
set ruler
set backspace=indent,eol,start
set laststatus=2
if has('persistent_undo')
  set undofile
endif

let mapleader = ","
" fix vim regex
nnoremap / /\v
vnoremap / /\v
" better case sensitivity in searches (all lowercase = insensitive, mixed-case = sensitive)
set ignorecase
set smartcase
" global substitution by default
set gdefault
" search options
set incsearch
set showmatch
set hlsearch
" clear out search highlighting
nnoremap <leader><space> :noh<cr>
" map tab to match brackets
"nnoremap <tab> %
"vnoremap <tab> %
" make text wrap
set wrap
set textwidth=79
set formatoptions=qrn1
if exists('+colorcolumn')
  set colorcolumn=85
endif
" TextMate style invisible characters
"set list
set listchars=tab:▸\ ,eol:¬,trail:-
nmap <leader>l :set list!<CR>
" force into vim movement keys
nnoremap <up> <nop>
nnoremap <down> <nop>
nnoremap <left> <nop>
nnoremap <right> <nop>
inoremap <up> <nop>
inoremap <down> <nop>
inoremap <left> <nop>
inoremap <right> <nop>
nnoremap j gj
nnoremap k gk
" remap : to ; to save a shift key
nnoremap ; :
" auto-save on focus lost
au FocusLost * :wa

" Configure supertab
let g:SuperTabCompletionContexts = ['s:ContextText', 's:ContextDiscover']
let g:SuperTabContextTextOmniPrecedence = ['&omnifunc', '&completefunc']
let g:SuperTabContextDiscoverDiscovery =
    \ ["&completefunc:<c-x><c-u>", "&omnifunc:<c-x><c-o>"]
"ruby
autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete
autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1
autocmd FileType ruby,eruby let g:rubycomplete_rails = 1
autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1
"improve autocomplete menu color
highlight Pmenu ctermbg=238 gui=bold

" leader commands
" strip all trailing whitespace in the current file
nnoremap <leader>W :%s/\s\+$//<cr>:let @/=''<CR>
" leader for Ack
nnoremap <leader>a :Ack 
" fold tags for HTML
nnoremap <leader>ft Vatzf
" sort CSS properties
nnoremap <leader>S ?{<CR>jV/^\s*\}?$<CR>k:sort<CR>:noh<CR>
" hard-wrap text paragraphs
nnoremap <leader>q gqip
" re-select just-pasted text
nnoremap <leader>v V`]
" Rainbow Parentheses - https://github.com/kien/rainbow_parentheses.vim
"nnoremap <leader>R :RainbowParenthesesToggleAll
"not working, not sure why... :(

" quicker ESC
"inoremap jj <ESC>

" statusline setup
set statusline=         "clear at load
set statusline=%t       "tail of the filename
set statusline+=[%{strlen(&fenc)?&fenc:'none'}, "file encoding
set statusline+=%{&ff}] "file format
set statusline+=%h      "help file flag
set statusline+=%m      "modified flag
set statusline+=%r      "read only flag
set statusline+=%y      "filetype
set statusline+=%{fugitive#statusline()} "git status
set statusline+=%{StatuslineTrailingSpaceWarning()}
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
set statusline+=%=      "left/right separator
set statusline+=%c,     "cursor column
set statusline+=%l/%L   "cursor line/total lines
set statusline+=\ %P    "percent through file

"return '[\s]' if trailing white space is detected
"return '' otherwise
function! StatuslineTrailingSpaceWarning()
    if !exists("b:statusline_trailing_space_warning")

        if !&modifiable
            let b:statusline_trailing_space_warning = ''
            return b:statusline_trailing_space_warning
        endif

        if search('\s\+$', 'nw') != 0
            let b:statusline_trailing_space_warning = '[\s]'
        else
            let b:statusline_trailing_space_warning = ''
        endif
    endif
    return b:statusline_trailing_space_warning
endfunction

" split window helpers
" open new vertical split and switch to it
nnoremap <leader>w <C-w>v<C-w>l
" switch windows with Ctrl-hjkl
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" YankRing mappings
nnoremap <silent> <F3> :YRShow<cr>
inoremap <silent> <F3> <ESC>:YRShow<cr>

" remap PgUp and PgDn to the Windows way
map <silent> <PageUp> 1000<C-U>
map <silent> <PageDown> 1000<C-D>
imap <silent> <PageUp> <C-O>1000<C-U>
imap <silent> <PageDown> <C-O>1000<C-D>

" no tabs, 2 spaces by default
set tabstop=2
set expandtab
set shiftwidth=2
set softtabstop=2
set autoindent

" enable mouse scroll wheel - doesn't work on remote systems
" set mouse=a

" enable search highlighting
set hlsearch

" Highlight current line and show trailing spaces
highlight CursorLine cterm=bold
set cursorline
" replaced above
"set list listchars=tab:._,trail:-

" Keep at least 3 lines above/below cursor in view
set scrolloff=3

" Press Space to turn off highlighting and clear any message already displayed.
:nnoremap <silent> <Space> :nohlsearch<Bar>:echo<CR>

" Press F7 to highlight the current word in the rest of the file
:nnoremap <F7> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>

" Various swapping functions
" To use gc to swap the current character with the next, without changing the cursor position:
:nnoremap <silent> gc xph
" To use gw to swap the current word with the next, without cursor changing position:
:nnoremap <silent> gw "_yiw:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR><c-o><c-l>:nohl<CR>
" To use gl to swap the current word with the previous, keeping cursor on current word: (This feels like "pushing" the word to the left.)
:nnoremap <silent> gl "_yiw?\w\+\_W\+\%#<CR>:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR>:nohl<CR><c-o><c-l>:nohl<CR>
" To use gr to swap the current word with the next, keeping cursor on current word: (This feels like "pushing" the word to the right.)
:nnoremap <silent> gr "_yiw:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR><c-o>/\w\+\_W\+<CR><c-l>:nohl<CR>
" To use g{ to swap the current paragraph with the next:
:nnoremap g{ {dap}p{
" Note: Mappings above which perform a search-and-replace (ones containing :s/)
" will operate incorrectly on words with accented characters. To adjust the
" mappings above to work with your locale, replace all \w with [alphabet] and \W
" with [^alphabet], where alphabet is the set of characters in your alphabet.
" :help /\w

" Pastetoggle for no code indenting on paste
nnoremap <F2> :set invpaste paste?<CR>
set pastetoggle=<F2>
set showmode

" Tag file from exuberant-ctag
"autocmd FileType java set tags=~/.tags
set tags=~/tags
set complete=.,w,b,u,t,i

" Tell vim to remember certain things when we exit
"  '10  :  marks will be remembered for up to 10 previously edited files
"  "100 :  will save up to 100 lines for each register
"  :40  :  up to 40 lines of command-line history will be remembered
"  %    :  saves and restores the buffer list
"  n... :  where to save the viminfo files
set viminfo='10,\"100,:40,%,n~/.viminfo

set guioptions+=a
function! MakePattern(text)
  let pat = escape(a:text, '\')
  let pat = substitute(pat, '\_s\+$', '\\s\\*', '')
  let pat = substitute(pat, '^\_s\+', '\\s\\*', '')
  let pat = substitute(pat, '\_s\+',  '\\_s\\+', 'g')
  return '\\V' . escape(pat, '\"')
endfunction
vnoremap <silent> <F7> :<C-U>let @/="<C-R>=MakePattern(@*)<CR>"<CR>:set hls<CR>

" BEGIN: Auto-save sessions
" http://vim.wikia.com/wiki/Go_away_and_come_back
" Modified by robin burchell <w00t@inspircd.org> to only load/save sessions if started with no arguments.
function! MakeSession()
  if g:sessionfile != ""
    echo "Saving."
    if (filewritable(g:sessiondir) != 2)
      exe 'silent !mkdir -p ' g:sessiondir
      redraw!
    endif
    exe "mksession! " . g:sessionfile
  endif
endfunction

function! LoadSession()
  if argc() == 0 && ! &diff
    let g:sessiondir = $HOME . "/.vim/sessions" . getcwd()
    let g:sessionfile = g:sessiondir . "/session.vim"
    if (filereadable(g:sessionfile))
      exe 'source ' g:sessionfile
    else
      echo "No session loaded."
    endif
  else
    let g:sessionfile = ""
    let g:sessiondir = ""
    call ResCur()
  endif
endfunction

function! ResCur()
  if line("'\"") <= line("$")
    normal! g`"
    return 1
  endif
endfunction

au VimEnter * nested :call LoadSession()
au VimLeave * :call MakeSession()
" END: Austo-save sessions

" Append modeline after last line in buffer.
" Use substitute() instead of printf() to handle '%%s' modeline in LaTeX
" files.
function! AppendModeline()
  let l:modeline = printf(" vim: set ts=%d sw=%d tw=%d :",
        \ &tabstop, &shiftwidth, &textwidth)
  let l:modeline = substitute(&commentstring, "%s", l:modeline, "")
  call append(line("$"), l:modeline)
endfunction
nnoremap <silent> <Leader>ml :call AppendModeline()<CR>

" Functions to move lines up and down with Ctrl-Up/Down
function! MoveLineUp()
  call MoveLineOrVisualUp(".", "")
endfunction

function! MoveLineDown()
  call MoveLineOrVisualDown(".", "")
endfunction

function! MoveVisualUp()
  call MoveLineOrVisualUp("'<", "'<,'>")
  normal gv
endfunction

function! MoveVisualDown()
  call MoveLineOrVisualDown("'>", "'<,'>")
  normal gv
endfunction

function! MoveLineOrVisualUp(line_getter, range)
  let l_num = line(a:line_getter)
  if l_num - v:count1 - 1 < 0
    let move_arg = "0"
  else
    let move_arg = a:line_getter." -".(v:count1 + 1)
  endif
  call MoveLineOrVisualUpOrDown(a:range."move ".move_arg)
endfunction

function! MoveLineOrVisualDown(line_getter, range)
  let l_num = line(a:line_getter)
  if l_num + v:count1 > line("$")
    let move_arg = "$"
  else
    let move_arg = a:line_getter." +".v:count1
  endif
  call MoveLineOrVisualUpOrDown(a:range."move ".move_arg)
endfunction

function! MoveLineOrVisualUpOrDown(move_arg)
  let col_num = virtcol(".")
  execute "silent! ".a:move_arg
  execute "normal! ".col_num."|"
endfunction

nnoremap <silent> <C-Up> :<C-u>call MoveLineUp()<CR>
nnoremap <silent> <C-Down> :<C-u>call MoveLineDown()<CR>
inoremap <silent> <C-Up> <C-o>:<C-u>call MoveLineUp()<CR>
inoremap <silent> <C-Down> <C-o>:<C-u>call MoveLineDown()<CR>
vnoremap <silent> <C-Up> :<C-u>call MoveVisualUp()<CR>
vnoremap <silent> <C-Down> :<C-u>call MoveVisualDown()<CR>

